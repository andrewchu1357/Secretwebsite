<!DOCTYPE html>
<html>
<head>
    <title>Neon Dash: Optimized</title>
    <style>
        body { margin: 0; background: #020202; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; }
        canvas { border: 2px solid #333; background: #050505; }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 900;
canvas.height = 500;

// --- CONFIGURATION ---
const GRAVITY = 0.75;
const JUMP_FORCE = -12.5;
const SPEED = 420; // Pixels per second (Delta-time based)
const GROUND_Y = 400;
const STATE = { COVER: 0, SELECT: 1, PLAYING: 2, DEAD: 3, WON: 4 };

let currentState = STATE.COVER;
let lastTime = 0;
let player = { x: 100, y: GROUND_Y, w: 30, h: 30, dy: 0, angle: 0, mode: 'cube', isHolding: false };
let obstacles = [];
let cameraX = 0;
let levelLength = 0;
let currentLevelId = 1;

// --- OPTIMIZED LEVEL BUILDER ---
let cx = 800;
function resetLevel(lvl) {
    obstacles = [];
    cx = 800;
    currentLevelId = lvl;
    
    if(lvl === 1) {
        addSpikes(1); addSpikes(2); addBlock(60, 200, true); addSpikes(3);
        addPortal('ship');
        for(let i=0; i<5; i++) {
            addBlock(60, 200, false, 0); // Ceiling
            addBlock(60, 200, false, 340); // Floor
            cx += 100;
        }
    } else {
        addBlock(50, 100); cx -= 150; addBlock(100, 100); cx -= 150; addBlock(150, 100);
        addPortal('ship');
        for(let i=0; i<8; i++) {
            addBlock(120, 100, false, 0);
            addBlock(120, 100, false, 280);
            cx += 50;
        }
    }
    obstacles.push({type: 'finish', x: cx + 400, y: 0, w: 50, h: 500});
    levelLength = cx + 400;
    
    player = { x: 100, y: GROUND_Y - 30, w: 30, h: 30, dy: 0, angle: 0, mode: 'cube', isHolding: false };
    cameraX = 0;
    currentState = STATE.PLAYING;
}

function addSpikes(n) { 
    for(let i=0; i<n; i++) obstacles.push({type: 'spike', x: cx + (i*45), y: GROUND_Y}); 
    cx += (n*45) + 300; 
}
function addBlock(h, w, s, yOverride) { 
    let y = yOverride !== undefined ? yOverride : GROUND_Y - h;
    obstacles.push({type: 'block', x: cx, y: y, w: w, h: h}); 
    if(s) obstacles.push({type: 'spike', x: cx + w/2 - 15, y: y - 30});
    cx += w + 250; 
}
function addPortal(m) { obstacles.push({type: 'portal', mode: m, x: cx, y: 200, w: 40, h: 100}); cx += 200; }

// --- GAME LOOP WITH DELTA TIME ---
function loop(timestamp) {
    let dt = (timestamp - lastTime) / 1000;
    if (dt > 0.1) dt = 0.1; // Cap dt to prevent huge leaps on lag
    lastTime = timestamp;

    update(dt);
    draw();
    requestAnimationFrame(loop);
}

function update(dt) {
    if (currentState !== STATE.PLAYING) return;

    // Move player based on time, not frames
    player.x += SPEED * dt;
    cameraX = player.x - 200;

    // Physics
    if (player.mode === 'cube') {
        player.dy += GRAVITY;
        player.y += player.dy;
        if (player.y < GROUND_Y - 30) player.angle += 360 * dt; // Rotate 1 full circle/sec
        else { player.y = GROUND_Y - 30; player.dy = 0; player.angle = Math.round(player.angle/90)*90; }
    } else {
        player.dy += (player.isHolding ? -0.8 : 0.5); // Ship logic
        player.dy = Math.max(-8, Math.min(8, player.dy));
        player.y += player.dy;
        player.angle = player.dy * 2;
        if (player.y > GROUND_Y - 30) { player.y = GROUND_Y - 30; player.dy = 0; }
        if (player.y < 0) { player.y = 0; player.dy = 0; }
    }

    // Optimized Collision (Only check objects near player)
    for (let obj of obstacles) {
        if (obj.x > player.x + 100 || obj.x + 100 < player.x) continue;

        if (player.x < obj.x + (obj.w || 30) - 5 && player.x + 25 > obj.x + 5 &&
            player.y < obj.y + (obj.h || 30) - 5 && player.y + 25 > obj.y + 5) {
            
            if (obj.type === 'spike') currentState = STATE.DEAD;
            if (obj.type === 'finish') currentState = STATE.WON;
            if (obj.type === 'portal') player.mode = obj.mode;
            if (obj.type === 'block') {
                if (player.y + 25 < obj.y + 15 && player.dy >= 0) { // Landed on top
                    player.y = obj.y - 30; player.dy = 0;
                } else { currentState = STATE.DEAD; }
            }
        }
    }
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Grid
    ctx.strokeStyle = "#111";
    for(let i=0; i<canvas.width; i+=50) {
        ctx.beginPath(); ctx.moveTo(i - (cameraX % 50), 0); ctx.lineTo(i - (cameraX % 50), canvas.height); ctx.stroke();
    }

    ctx.save();
    ctx.translate(-cameraX, 0);
    
    // Draw Level
    ctx.strokeStyle = "#0ff"; ctx.beginPath(); ctx.moveTo(cameraX, GROUND_Y); ctx.lineTo(cameraX+canvas.width, GROUND_Y); ctx.stroke();
    
    obstacles.forEach(obj => {
        if(obj.x + 400 < cameraX || obj.x - 900 > cameraX) return; // Culling
        ctx.fillStyle = obj.type === 'block' ? "#000" : (obj.type === 'finish' ? "yellow" : "#fff");
        if(obj.type === 'block') { ctx.fillRect(obj.x, obj.y, obj.w, obj.h); ctx.strokeRect(obj.x, obj.y, obj.w, obj.h); }
        else if(obj.type === 'spike') {
            ctx.beginPath(); ctx.moveTo(obj.x, obj.y); ctx.lineTo(obj.x+15, obj.y-30); ctx.lineTo(obj.x+30, obj.y); ctx.fill();
        } else if(obj.type === 'portal') {
            ctx.fillStyle = obj.mode === 'ship' ? "#f0f" : "#0f0"; ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
        } else if(obj.type === 'finish') { ctx.fillRect(obj.x, 0, 50, 500); }
    });

    // Player
    ctx.save();
    ctx.translate(player.x + 15, player.y + 15);
    ctx.rotate(player.angle * Math.PI / 180);
    ctx.fillStyle = player.mode === 'ship' ? "#f0f" : "#0ff";
    ctx.fillRect(-15, -15, 30, 30);
    ctx.restore();
    
    ctx.restore();

    // UI
    if(currentState === STATE.COVER) drawOverlay("NEON DASH", "CLICK TO START");
    if(currentState === STATE.SELECT) {
        ctx.fillStyle = "white"; ctx.font = "30px Arial"; ctx.textAlign = "center";
        ctx.fillText("SELECT LEVEL", 450, 150);
        ctx.strokeRect(350, 200, 200, 50); ctx.fillText("LEVEL 1", 450, 235);
        ctx.strokeRect(350, 280, 200, 50); ctx.fillText("LEVEL 2", 450, 315);
    }
    if(currentState === STATE.DEAD || currentState === STATE.WON) {
        drawOverlay(currentState === STATE.DEAD ? "CRASHED" : "WINNER!", "SPACE to RESTART");
        // Home Icon
        ctx.strokeStyle = "white"; ctx.strokeRect(425, 350, 50, 50);
        ctx.beginPath(); ctx.moveTo(425, 370); ctx.lineTo(450, 350); ctx.lineTo(475, 370); ctx.stroke();
        ctx.fillText("HOME", 450, 430);
    }
}

function drawOverlay(t1, t2) {
    ctx.fillStyle = "rgba(0,0,0,0.8)"; ctx.fillRect(0,0,900,500);
    ctx.fillStyle = "white"; ctx.textAlign = "center";
    ctx.font = "50px Arial"; ctx.fillText(t1, 450, 200);
    ctx.font = "20px Arial"; ctx.fillText(t2, 450, 260);
}

// --- INPUTS ---
window.addEventListener("mousedown", (e) => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left; const my = e.clientY - rect.top;

    if(currentState === STATE.COVER) currentState = STATE.SELECT;
    else if(currentState === STATE.SELECT) {
        if(mx > 350 && mx < 550 && my > 200 && my < 250) resetLevel(1);
        if(mx > 350 && mx < 550 && my > 280 && my < 330) resetLevel(2);
    }
    else if(currentState === STATE.PLAYING) player.isHolding = true;
    else { // HOME button click detection
        if(mx > 425 && mx < 475 && my > 350 && my < 400) currentState = STATE.SELECT;
        else resetLevel(currentLevelId);
    }
});
window.addEventListener("mouseup", () => player.isHolding = false);
window.addEventListener("keydown", (e) => {
    if(e.code === "Space") {
        if(currentState === STATE.PLAYING) {
            if(player.mode === 'cube' && player.y >= GROUND_Y - 31) player.dy = JUMP_FORCE;
            player.isHolding = true;
        } else if(currentState === STATE.DEAD || currentState === STATE.WON) {
            resetLevel(currentLevelId);
        }
    }
});
window.addEventListener("keyup", (e) => { if(e.code === "Space") player.isHolding = false; });

requestAnimationFrame(loop);
</script>
</body>
</html>