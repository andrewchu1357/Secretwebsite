<!DOCTYPE html>
<html>
<head>
    <title>Geometry Dash Advanced</title>
    <style>
        body { margin: 0; background: #000; display: flex; justify-content: center; align-items: center; height: 100vh; overflow: hidden; font-family: 'Segoe UI', sans-serif; }
        canvas { border: 2px solid #333; box-shadow: 0 0 50px rgba(0,255,255,0.2); }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 800;
canvas.height = 400;

// --- Constants & Level Data ---
const GRAVITY = 0.6;
const STATE = { MENU: 0, PLAYING: 1, DEAD: 2 };
let gameState = STATE.MENU;

// Level Definition: S = Spike, B = Block, P = Portal(UFO), C = Portal(Cube)
const levelMap = [
    "      B     B                                  ",
    "     BBB   BBB       P        S   S   S        ",
    "                                               ",
    "BBBBBBBBBBBBBBBB      BBBBBB    C    BBBBBBBBBB",
    "                    BB        BB               "
];

let levelObjects = [];
let cameraX = 0;
let player = { x: 50, y: 200, w: 30, h: 30, velY: 0, mode: 'cube', rotation: 0 };

function buildLevel() {
    levelObjects = [];
    cameraX = 0;
    player.x = 50; player.y = 200; player.velY = 0; player.mode = 'cube';
    
    const tileSize = 40;
    levelMap.forEach((row, y) => {
        [...row].forEach((char, x) => {
            const posX = x * tileSize;
            const posY = y * tileSize;
            if (char === 'B') levelObjects.push({ type: 'block', x: posX, y: posY, w: tileSize, h: tileSize });
            if (char === 'S') levelObjects.push({ type: 'spike', x: posX, y: posY, w: tileSize, h: tileSize });
            if (char === 'P') levelObjects.push({ type: 'portal', mode: 'ufo', x: posX, y: posY, w: 20, h: 60 });
            if (char === 'C') levelObjects.push({ type: 'portal', mode: 'cube', x: posX, y: posY, w: 20, h: 60 });
        });
    });
}

function update() {
    if (gameState !== STATE.PLAYING) return;

    // Movement & Camera
    player.x += 5;
    cameraX = player.x - 150;

    // Physics
    player.velY += GRAVITY;
    player.y += player.velY;

    let onGround = false;

    // Collision Logic
    levelObjects.forEach(obj => {
        // Simple AABB Collision
        if (player.x < obj.x + obj.w && player.x + player.w > obj.x &&
            player.y < obj.y + obj.h && player.y + player.h > obj.y) {
            
            if (obj.type === 'block') {
                // Land on top
                if (player.velY > 0 && player.y + player.h < obj.y + 20) {
                    player.y = obj.y - player.h;
                    player.velY = 0;
                    onGround = true;
                } else { gameState = STATE.DEAD; } // Side hit
            } else if (obj.type === 'spike') {
                gameState = STATE.DEAD;
            } else if (obj.type === 'portal') {
                player.mode = obj.mode;
            }
        }
    });

    // Rotation
    if (player.mode === 'cube') {
        if (!onGround) player.rotation += 5;
        else player.rotation = Math.round(player.rotation / 90) * 90;
    }

    // Progress Bar (Percent)
    const totalDist = levelMap[0].length * 40;
    document.title = `Progress: ${Math.floor((player.x / totalDist) * 100)}%`;
}

function draw() {
    ctx.fillStyle = "#000814"; // Dark Space Blue
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.save();
    ctx.translate(-cameraX, 0);

    // Draw Objects
    levelObjects.forEach(obj => {
        if (obj.type === 'block') {
            ctx.fillStyle = "#111";
            ctx.strokeStyle = "#0ff";
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
        } else if (obj.type === 'spike') {
            ctx.fillStyle = "white";
            ctx.beginPath();
            ctx.moveTo(obj.x, obj.y + obj.h);
            ctx.lineTo(obj.x + obj.w / 2, obj.y);
            ctx.lineTo(obj.x + obj.w, obj.y + obj.h);
            ctx.fill();
        } else if (obj.type === 'portal') {
            ctx.fillStyle = obj.mode === 'ufo' ? "#f0f" : "#0f0";
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
        }
    });

    // Draw Player
    ctx.save();
    ctx.translate(player.x + player.w/2, player.y + player.h/2);
    if (player.mode === 'cube') ctx.rotate(player.rotation * Math.PI / 180);
    ctx.fillStyle = "#0ff";
    ctx.shadowBlur = 10; ctx.shadowColor = "#0ff";
    if (player.mode === 'ufo') {
        ctx.beginPath(); ctx.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2); ctx.fill();
    } else {
        ctx.fillRect(-15, -15, 30, 30);
    }
    ctx.restore();

    ctx.restore();

    // UI Overlays
    if (gameState === STATE.MENU) {
        ctx.fillStyle = "white"; ctx.font = "30px Arial";
        ctx.fillText("GEOMETRY CLONE", 270, 180);
        ctx.font = "15px Arial"; ctx.fillText("CLICK TO START", 340, 210);
    } else if (gameState === STATE.DEAD) {
        ctx.fillStyle = "rgba(255,0,0,0.3)"; ctx.fillRect(0,0,800,400);
        ctx.fillStyle = "white"; ctx.fillText("CRASHED! CLICK TO RETRY", 240, 200);
    }
}

function handleInput() {
    if (gameState === STATE.MENU) { buildLevel(); gameState = STATE.PLAYING; }
    else if (gameState === STATE.DEAD) { buildLevel(); gameState = STATE.PLAYING; }
    else {
        if (player.mode === 'cube') {
            // Check if on ground/block logic simplified for demo
            player.velY = -11;
        } else {
            player.velY = -8; // UFO Flap
        }
    }
}

window.addEventListener("mousedown", handleInput);
window.addEventListener("keydown", e => { if(e.code === "Space") handleInput(); });

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();
</script>
</body>
</html>