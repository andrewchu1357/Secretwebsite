<!DOCTYPE html>
<html>
<head>
    <title>Neon Dash: Dual Levels</title>
    <style>
        body { 
            margin: 0; 
            background: #050505; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
            overflow: hidden; 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
            user-select: none;
        }
        canvas { 
            border: 4px solid #444; 
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.1); 
            background: linear-gradient(to bottom, #111, #1a1a1a);
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");
canvas.width = 900;
canvas.height = 500;

// --- CONFIGURATION ---
// Tweak these to change the "feel"
const GRAVITY = 0.85;       // Increased for snappier falls
const JUMP_FORCE = -13.5;   // Stronger jump to compensate for gravity
const SHIP_LIFT = -0.5;     // Thrust power for ship
const SHIP_GRAVITY = 0.3;   // Lighter gravity for ship
const SPEED = 7.5;          // Faster scrolling
const GROUND_Y = 400;

// --- GAME STATES ---
const STATE = { MENU: 0, PLAYING: 1, DEAD: 2, WON: 3 };
let currentState = STATE.MENU;

// --- VARIABLES ---
let player = { x: 100, y: GROUND_Y, w: 30, h: 30, dy: 0, angle: 0, mode: 'cube' };
let cameraX = 0;
let obstacles = [];
let particles = [];
let levelLength = 0;
let currentLevelId = 1;

// --- HITBOXES ---
// Reduces the collision box size slightly to be "fair"
const HITBOX_PAD = 6; 

// --- LEVEL BUILDER ---
let x = 800; // Global cursor for level building

function resetBuilder() {
    obstacles = [];
    x = 800;
}

function addSpike(count) {
    for(let i=0; i<count; i++) {
        // Spikes have a slightly smaller hitbox defined here visually
        obstacles.push({type: 'spike', x: x + (i*40), y: GROUND_Y, w: 30, h: 30});
    }
    x += (count * 40) + 150; 
}

function addPlatform(height, width, spikeConfig) {
    // spikeConfig: 0=none, 1=top, 2=bottom, 3=inside
    obstacles.push({type: 'block', x: x, y: GROUND_Y - height, w: width, h: height});
    
    if(spikeConfig === 1) { // Spike on top
        obstacles.push({type: 'spike', x: x + width/2 - 15, y: GROUND_Y - height - 30, w: 30, h: 30});
    }
    x += width + 180;
}

function addPortal(mode, yPos) {
    obstacles.push({type: mode === 'ship' ? 'portal_ship' : 'portal_cube', x: x, y: yPos || 250, w: 40, h: 80});
    x += 100;
}

// --- LEVEL DEFINITIONS ---

function buildLevel1() {
    // LEVEL 1: STEREO MADNESS STYLE
    resetBuilder();
    
    // Intro
    addSpike(1);
    addSpike(2);
    addPlatform(60, 200, 0);
    addSpike(2);
    addPlatform(100, 200, 1); // Spike on top
    
    // Ship Section
    addPortal('ship', 250);
    x += 200;
    
    for(let i=0; i<8; i++) {
        // Simple tunnel
        obstacles.push({type: 'block', x: x + (i*150), y: 0, w: 150, h: 80}); // Ceiling
        obstacles.push({type: 'block', x: x + (i*150), y: 350 + Math.sin(i)*50, w: 150, h: 100}); // Floor
    }
    x += 1200;

    // Outro
    addPortal('cube', 250);
    x += 300;
    addSpike(3); // Triple spike (Hard!)
    addPlatform(50, 400, 0);
    
    // Finish
    obstacles.push({type: 'finish', x: x, y: 0, w: 50, h: 500});
    levelLength = x;
}

function buildLevel2() {
    // LEVEL 2: ELECTRO DYNAMICS STYLE (Harder)
    resetBuilder();

    // Fast Stairs
    addPlatform(50, 100, 0); x -= 100; // Reduce gap
    addPlatform(100, 100, 0); x -= 100;
    addPlatform(150, 100, 0);
    
    // The Drop
    x += 100;
    addSpike(2);
    addPlatform(100, 300, 1); // Spike on top
    
    // Tight Ship
    addPortal('ship', 200);
    x += 300;
    
    for(let i=0; i<12; i++) {
        // Jagged teeth
        let h = 100 + (i%2)*100; // Alternating height
        obstacles.push({type: 'block', x: x + (i*100), y: 0, w: 100, h: h}); 
        obstacles.push({type: 'block', x: x + (i*100), y: 400 - h, w: 100, h: h});
    }
    x += 1300;
    
    // Precision Cube
    addPortal('cube', 300);
    x += 300;
    addSpike(1); addSpike(1); addSpike(1); // Single spikes spaced out
    addPlatform(120, 100, 0);
    
    obstacles.push({type: 'finish', x: x, y: 0, w: 50, h: 500});
    levelLength = x;
}

// --- CORE LOGIC ---

function init(levelId) {
    currentLevelId = levelId;
    if(levelId === 1) buildLevel1();
    else buildLevel2();

    player = { x: 100, y: GROUND_Y - 30, w: 30, h: 30, dy: 0, angle: 0, mode: 'cube', onGround: true };
    cameraX = 0;
    particles = [];
    currentState = STATE.PLAYING;
}

function spawnParticles(x, y, color) {
    for(let i=0; i<12; i++) {
        particles.push({
            x: x, y: y,
            vx: (Math.random() - 0.5) * 15,
            vy: (Math.random() - 0.5) * 15,
            life: 1.0,
            color: color
        });
    }
}

function update() {
    if (currentState !== STATE.PLAYING) return;

    // 1. Move Player & Camera
    player.x += SPEED;
    cameraX = player.x - 200;

    // 2. Physics Engine
    if (player.mode === 'cube') {
        player.dy += GRAVITY;
        player.y += player.dy;
        
        // Cube Rotation
        if (!player.onGround) player.angle += 6; // Faster rotation
        else player.angle = Math.round(player.angle / 90) * 90;

    } else if (player.mode === 'ship') {
        player.dy += SHIP_GRAVITY; 
        if(player.isHolding) player.dy += SHIP_LIFT; // Thrust
        
        // Cap velocity for ship to prevent clipping
        if(player.dy > 8) player.dy = 8;
        if(player.dy < -8) player.dy = -8;

        player.y += player.dy;
        player.angle = player.dy * 3; // Tilt ship
    }

    // 3. Ground/Ceiling Limits
    if (player.y > GROUND_Y - 30) {
        player.y = GROUND_Y - 30;
        player.dy = 0;
        player.onGround = true;
    } else {
        player.onGround = false;
    }
    if (player.y < 0) { player.y = 0; player.dy = 0; }

    // 4. Collision Detection
    // We create a "Hitbox" that is slightly smaller than the visual player
    const pRect = {
        l: player.x + HITBOX_PAD,
        r: player.x + player.w - HITBOX_PAD,
        t: player.y + HITBOX_PAD,
        b: player.y + player.h - HITBOX_PAD
    };

    obstacles.forEach(obj => {
        // Object Hitbox
        const oRect = {
            l: obj.x + (obj.type === 'spike' ? 10 : 0), // Spikes are thinner
            r: obj.x + (obj.w || 30) - (obj.type === 'spike' ? 10 : 0),
            t: obj.y + (obj.type === 'spike' ? 10 : 0),
            b: obj.y + (obj.h || 30)
        };

        // AABB Check
        if (pRect.l < oRect.r && pRect.r > oRect.l &&
            pRect.t < oRect.b && pRect.b > oRect.t) {

            if (obj.type === 'spike') {
                die();
            }
            else if (obj.type === 'portal_ship') {
                player.mode = 'ship';
                spawnParticles(player.x, player.y, '#f0f');
            }
            else if (obj.type === 'portal_cube') {
                player.mode = 'cube';
                player.angle = 0;
                spawnParticles(player.x, player.y, '#0ff');
            }
            else if (obj.type === 'block') {
                // Precise Block Collision
                // Determine if we hit the top, bottom, or side
                const prevY = player.y - player.dy;
                
                // Land on Top
                if (prevY + player.h <= obj.y + 10 && player.dy >= 0) {
                    player.y = obj.y - player.h;
                    player.dy = 0;
                    player.onGround = true;
                    if(player.mode === 'cube') player.angle = Math.round(player.angle / 90) * 90;
                } 
                // Hit Ceiling
                else if (prevY >= obj.y + obj.h - 10 && player.dy < 0) {
                     player.y = obj.y + obj.h;
                     player.dy = 0;
                } 
                // Hit Side (Death)
                else {
                    die();
                }
            }
            else if (obj.type === 'finish') {
                currentState = STATE.WON;
            }
        }
    });

    // 5. Particles Update
    for(let i=particles.length-1; i>=0; i--) {
        particles[i].x += particles[i].vx;
        particles[i].y += particles[i].vy;
        particles[i].life -= 0.05;
        if(particles[i].life <= 0) particles.splice(i, 1);
    }
}

function die() {
    spawnParticles(player.x, player.y, '#fff');
    currentState = STATE.DEAD;
}

// --- RENDERING ---

function draw() {
    // Background
    ctx.fillStyle = currentLevelId === 1 ? "#100010" : "#000510"; // Purple vs Blue Tint
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    let gridX = -(cameraX * 0.5) % 60;
    for (let i = gridX; i < canvas.width; i += 60) {
        ctx.beginPath(); ctx.moveTo(i, 0); ctx.lineTo(i, canvas.height); ctx.stroke();
    }
    
    ctx.save();
    ctx.translate(-cameraX, 0);

    // Floor
    ctx.strokeStyle = currentLevelId === 1 ? "#d0f" : "#0df"; // Neon Color
    ctx.lineWidth = 3;
    ctx.beginPath(); ctx.moveTo(cameraX, GROUND_Y); ctx.lineTo(cameraX + canvas.width, GROUND_Y); ctx.stroke();

    // Objects
    obstacles.forEach(obj => {
        if (obj.type === 'spike') {
            ctx.fillStyle = "#fff";
            // Draw accurate triangle
            ctx.beginPath();
            ctx.moveTo(obj.x, obj.y);
            ctx.lineTo(obj.x + 15, obj.y - 30);
            ctx.lineTo(obj.x + 30, obj.y);
            ctx.fill();
            // Debug Hitbox (Uncomment to see strict hitbox)
            // ctx.strokeStyle = "red"; ctx.lineWidth=1; ctx.strokeRect(obj.x+10, obj.y+10, 10, 20);
        } else if (obj.type === 'block') {
            ctx.fillStyle = "#000";
            ctx.strokeStyle = currentLevelId === 1 ? "#d0f" : "#0df";
            ctx.lineWidth = 2;
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.strokeRect(obj.x, obj.y, obj.w, obj.h);
        } else if (obj.type.includes('portal')) {
            ctx.fillStyle = obj.type === 'portal_ship' ? "#ff00ff" : "#00ff00";
            ctx.globalAlpha = 0.8;
            ctx.fillRect(obj.x, obj.y, obj.w, obj.h);
            ctx.globalAlpha = 1.0;
        } else if (obj.type === 'finish') {
            ctx.fillStyle = "#ffff00";
            ctx.fillRect(obj.x, 0, 50, 500);
        }
    });

    // Player
    if (currentState === STATE.PLAYING || currentState === STATE.WON) {
        ctx.save();
        ctx.translate(player.x + 15, player.y + 15);
        ctx.rotate(player.angle * Math.PI / 180);
        
        ctx.fillStyle = player.mode === 'ship' ? "#ff00ff" : "#00ffff";
        ctx.shadowBlur = 15;
        ctx.shadowColor = ctx.fillStyle;
        
        if(player.mode === 'ship') {
            ctx.beginPath(); ctx.moveTo(-15, 10); ctx.lineTo(15, 0); ctx.lineTo(-15, -10); ctx.fill();
        } else {
            ctx.fillRect(-15, -15, 30, 30);
            ctx.fillStyle = "black"; // Inner eye
            ctx.fillRect(0, -5, 10, 10);
        }
        ctx.restore();
    }

    // Particles
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life;
        ctx.fillRect(p.x, p.y, 6, 6);
    });
    ctx.globalAlpha = 1.0;

    ctx.restore();

    // UI
    if (currentState === STATE.MENU) {
        drawMenu();
    } else if (currentState === STATE.DEAD) {
        drawOverlay("CRASHED!", "Press SPACE to Retry");
    } else if (currentState === STATE.WON) {
        drawOverlay("LEVEL COMPLETE!", "Press M for Menu");
    } else {
        // Progress Bar
        let pct = Math.min(1, Math.max(0, player.x / levelLength));
        ctx.fillStyle = "#444"; ctx.fillRect(250, 20, 400, 15);
        ctx.fillStyle = currentLevelId === 1 ? "#d0f" : "#0df"; ctx.fillRect(250, 20, 400 * pct, 15);
        ctx.strokeStyle = "white"; ctx.strokeRect(250, 20, 400, 15);
    }
}

function drawMenu() {
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    ctx.font = "bold 50px Segoe UI";
    ctx.shadowBlur = 10; ctx.shadowColor = "white";
    ctx.fillText("NEON DASH", canvas.width/2, 100);
    ctx.shadowBlur = 0;
    
    // Level Buttons (Visual only, logic in mouse handler)
    drawButton(1, "Stereo Madness", "#d0f", 200);
    drawButton(2, "Electro Dynamics", "#0df", 350);
}

function drawButton(id, text, color, y) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.strokeRect(canvas.width/2 - 150, y, 300, 60);
    ctx.fillStyle = color;
    ctx.font = "25px Segoe UI";
    ctx.fillText(text, canvas.width/2, y + 40);
}

function drawOverlay(title, sub) {
    ctx.fillStyle = "rgba(0,0,0,0.7)";
    ctx.fillRect(0,0,canvas.width, canvas.height);
    ctx.textAlign = "center";
    ctx.fillStyle = "white";
    ctx.font = "bold 50px Segoe UI";
    ctx.fillText(title, canvas.width/2, 220);
    ctx.font = "20px Segoe UI";
    ctx.fillText(sub, canvas.width/2, 270);
}

// --- INPUT ---
function handleInput(e) {
    if(e.code === "Space") e.preventDefault(); // Stop scroll

    if (currentState === STATE.MENU) {
        // Simple click zones for menu
        if (e.type === 'mousedown') {
            const rect = canvas.getBoundingClientRect();
            const my = e.clientY - rect.top;
            if(my > 200 && my < 260) init(1);
            if(my > 350 && my < 410) init(2);
        }
    } else if (currentState === STATE.DEAD) {
        if(e.code === 'Space' || e.type === 'mousedown') init(currentLevelId);
    } else if (currentState === STATE.WON) {
        if(e.code === 'KeyM') currentState = STATE.MENU;
    } else if (currentState === STATE.PLAYING) {
        if (e.type === 'mousedown' || e.code === 'Space') {
            if (player.mode === 'cube') {
                if (player.onGround) player.dy = JUMP_FORCE;
            } else if (player.mode === 'ship') {
                player.isHolding = true;
            }
        }
    }
}

window.addEventListener("mousedown", handleInput);
window.addEventListener("keydown", handleInput);
window.addEventListener("mouseup", () => player.isHolding = false);
window.addEventListener("keyup", (e) => { if(e.code==='Space') player.isHolding = false; });

function loop() { update(); draw(); requestAnimationFrame(loop); }
loop();

</script>
</body>
</html>